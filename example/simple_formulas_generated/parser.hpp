// Automatically generated by github.com:belous-dp/mt-lab4-parsers-generator.git

#pragma once

#include "tree.hpp"
#include "ctre.hpp"

#include <cctype>
#include <istream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <vector>

using namespace std::string_literals;

enum class token { VAR, OR, AND, NOT, LP, RP, _END };

struct lexer_exception : std::runtime_error {
  using std::runtime_error::runtime_error;
};

struct lexer {

  lexer(std::istream& is) {
    if (!is) {
      throw lexer_exception{"stream is not opened"};
    }
    buf_ = gulp(is);
    input = buf_;
  }

  token cur_token() const noexcept {
    return t;
  }

  std::string cur_token_val() const noexcept {
    return std::string{lexeme};
  }

  std::string info() const noexcept {
    return "'"s + input.front() + "' at pos " + std::to_string(pos);
  }

  token next_token() {
    while (!is_eof() && is_space()) {
      input.remove_prefix(1);
      pos++;
    }
    if (is_eof()) {
      t = token::_END;
      return t;
    }
    if (auto m = ctre::starts_with<"x[0-7]">(input)) {
        t = token::VAR;
        take(m.size());
    } else if (input.starts_with("|")) {
        t = token::OR;
        take(1);
    } else if (input.starts_with("&")) {
        t = token::AND;
        take(1);
    } else if (input.starts_with("~")) {
        t = token::NOT;
        take(1);
    } else if (input.starts_with("(")) {
        t = token::LP;
        take(1);
    } else if (input.starts_with(")")) {
        t = token::RP;
        take(1);
    }
    return t;
  }

private:
  std::string gulp(std::istream &in) {
    std::string ret;
    char buffer[4096];
    while (in.read(buffer, sizeof(buffer)))
      ret.append(buffer, sizeof(buffer));
    ret.append(buffer, in.gcount());
    return ret;
  }

  bool is_eof() const noexcept {
    return input.empty();
  }

  bool is_space() const noexcept {
    return std::isspace(static_cast<unsigned char>(input.front()));
  }

  void take(size_t n) {
    lexeme = input.substr(0, n);
    input.remove_prefix(n);
    pos += n;
  }

  std::string buf_;
  std::string_view input;
  std::string_view lexeme;
  size_t pos{0};
  token t;
  char ch;
};


// === arithmetization structs ===

using var_val_t = std::array<uint8_t, MAXN + 1>;

// primitives: calculatable, variable, one_minus, multiply
struct calculatable {
    int calculate(const var_val_t& variables_values) {
        auto res = calculate_impl(variables_values);
        assert(res == 0 || res == 1);
        return res;
    }

protected:
    virtual ~calculatable() = default;
    virtual int calculate_impl(const var_val_t& variables_values) = 0;
};

using expr_ptr = std::unique_ptr<calculatable>;

struct variable : calculatable {
    variable(uint8_t id) : id(id) {
        assert(0 < id && id <= MAXN);
    }

private:
    int calculate_impl(const var_val_t& variables_values) override {
        return variables_values[id];
    }

    uint8_t id;
};

struct one_minus : calculatable {
    one_minus(expr_ptr&& expr) : expr(std::move(expr)) {}
    one_minus(calculatable* p) : expr(p) {}

private:
    int calculate_impl(const var_val_t& variables_values) override {
        return 1 - expr->calculate(variables_values);
    }

    expr_ptr expr;
};

struct product : calculatable {
    product(expr_ptr&& lhs, expr_ptr&& rhs) : lhs(std::move(lhs)), rhs(std::move(rhs)) {}
    product(calculatable* lp, calculatable* rp) : lhs(lp), rhs(rp) {}

private:
    int calculate_impl(const var_val_t& variables_values) override {
        return lhs->calculate(variables_values) * rhs->calculate(variables_values);
    }

    expr_ptr lhs;
    expr_ptr rhs;
};

// !== arithmetization structs !==

// === arithmetization helpers ===

expr_ptr a_not(expr_ptr&& expr) {
    return expr_ptr{new one_minus(std::move(expr))};
}

expr_ptr a_and(expr_ptr&& lhs, expr_ptr&& rhs) {
    return expr_ptr{new product(std::move(lhs), std::move(rhs))};
}

expr_ptr a_or(expr_ptr&& lhs, expr_ptr&& rhs) {
    return a_not(a_and(a_not(std::move(lhs)), a_not(std::move(rhs))));
}

expr_ptr a_var(std::string const& s) {
    assert(s.size() == 2 && '1' <= s[1] && s[1] <= '7');
    return expr_ptr{new variable(s[1] - '0')};
}

// !== arithmetization helpers !==

struct parser_exception : std::runtime_error {
  using std::runtime_error::runtime_error;
};

class parser {
  struct lexer lexer;

  struct e : node {
    e() : node("e") {};
    expr_ptr expr;
  };
  e e() {
    auto _res = (struct e){};
    switch (lexer.cur_token()) {
    case token::NOT:
    case token::LP:
    case token::VAR: {
      auto _1 = o();
      _res.children.emplace_back(_1);
      auto _2 = ep(std::move(_1.expr));
      _res.children.emplace_back(_2);
      _res.expr = std::move(_2.expr);
      break;
    }
    default:
      throw invalid_token("e");
    }
    return _res;
  }

  struct ep : node {
    ep() : node("ep") {};
    expr_ptr expr;
  };
  ep ep(expr_ptr&& acc) {
    auto _res = (struct ep){};
    switch (lexer.cur_token()) {
    case token::OR: {
      auto _1 = lexer.cur_token_val();
      _res.children.emplace_back(_1);
      lexer.next_token();
      auto _2 = o();
      _res.children.emplace_back(_2);
      auto _3 = ep(a_or(std::move(acc), std::move(_2.expr)));
      _res.children.emplace_back(_3);
      _res.expr = std::move(_3.expr);
      break;
    }
    case token::_END:
    case token::RP: {
      _res.empty = true;
      _res.expr = std::move(acc);
      break;
    }
    default:
      throw invalid_token("ep");
    }
    return _res;
  }

  struct o : node {
    o() : node("o") {};
    expr_ptr expr;
  };
  o o() {
    auto _res = (struct o){};
    switch (lexer.cur_token()) {
    case token::NOT:
    case token::LP:
    case token::VAR: {
      auto _1 = a();
      _res.children.emplace_back(_1);
      auto _2 = op(std::move(_1.expr));
      _res.children.emplace_back(_2);
      _res.expr = std::move(_2.expr);
      break;
    }
    default:
      throw invalid_token("o");
    }
    return _res;
  }

  struct op : node {
    op() : node("op") {};
    expr_ptr expr;
  };
  op op(expr_ptr&& acc) {
    auto _res = (struct op){};
    switch (lexer.cur_token()) {
    case token::AND: {
      auto _1 = lexer.cur_token_val();
      _res.children.emplace_back(_1);
      lexer.next_token();
      auto _2 = a();
      _res.children.emplace_back(_2);
      auto _3 = op(a_and(std::move(acc), std::move(_2.expr)));
      _res.children.emplace_back(_3);
      _res.expr = std::move(_3.expr);
      break;
    }
    case token::_END:
    case token::OR:
    case token::RP: {
      _res.empty = true;
      _res.expr = std::move(acc);
      break;
    }
    default:
      throw invalid_token("op");
    }
    return _res;
  }

  struct a : node {
    a() : node("a") {};
    expr_ptr expr;
  };
  a a() {
    auto _res = (struct a){};
    switch (lexer.cur_token()) {
    case token::NOT: {
      auto _1 = lexer.cur_token_val();
      _res.children.emplace_back(_1);
      lexer.next_token();
      auto _2 = n();
      _res.children.emplace_back(_2);
      _res.expr = a_not(std::move(_2.expr));
      break;
    }
    case token::LP:
    case token::VAR: {
      auto _1 = n();
      _res.children.emplace_back(_1);
      _res.expr = std::move(_1.expr);
      break;
    }
    default:
      throw invalid_token("a");
    }
    return _res;
  }

  struct n : node {
    n() : node("n") {};
    expr_ptr expr;
  };
  n n() {
    auto _res = (struct n){};
    switch (lexer.cur_token()) {
    case token::LP: {
      auto _1 = lexer.cur_token_val();
      _res.children.emplace_back(_1);
      lexer.next_token();
      auto _2 = e();
      _res.children.emplace_back(_2);
      auto _3 = lexer.cur_token_val();
      _res.children.emplace_back(_3);
      lexer.next_token();
      _res.expr = std::move(_2.expr);
      break;
    }
    case token::VAR: {
      auto _1 = lexer.cur_token_val();
      _res.children.emplace_back(_1);
      lexer.next_token();
      _res.expr = a_var(_1);
      break;
    }
    default:
      throw invalid_token("n");
    }
    return _res;
  }

  parser_exception invalid_token(std::string&& n) {
    auto reason = lexer.cur_token() == token::_END
                      ? "expected a token, but got EOF"
                      : ("unexpected token " + lexer.info());
    return parser_exception{n + ": " + reason};
  }

public:
  parser(std::istream& is) : lexer(is) {}

  struct e parse() {
    lexer.next_token();
    return e();
  }
};
