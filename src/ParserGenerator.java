import generated.GrammarLexer;
import generated.GrammarParser;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

public class ParserGenerator {
    private final Path grammarPath, outDir;
    private final Map<String, Set<String>> FIRST = new HashMap<>();
    private final Map<String, Set<String>> FOLLOW = new HashMap<>();
    private BufferedWriter out;

    ParserGenerator(String grammarPath, String outDir) throws FileNotFoundException {
        this.grammarPath = Path.of(grammarPath);
        if (!Files.exists(this.grammarPath)) {
            throw new FileNotFoundException("Grammar file not found: " + grammarPath);
        }
        this.outDir = Path.of(outDir);
    }

    public void run() throws IOException {
        var inpParser = new GrammarParser(
                new CommonTokenStream(new GrammarLexer(CharStreams.fromPath(grammarPath)))
        );
        var initVisitor = new CollectRulesVisitor();
        initVisitor.visit(inpParser.lang());

        if (!checkLL1(initVisitor.getNonterminals())) {
            throw new InvalidGrammarException("grammar is not an LL(1)");
        }

        initializeOutputStreams();
        try {
            includeHeaders();
            createTokensEnum(initVisitor.getTerminals());
            createLexer(initVisitor.getTerminals());
            createParser(initVisitor.getNonterminals(), initVisitor.getIncludes());
        } finally {
            out.close();
        }
    }

    private void initializeOutputStreams() throws IOException {
        Files.createDirectories(outDir);
        var justCopy = List.of("CMakeLists.txt", "main.cpp", "tree.hpp", "ctre.hpp");
        for (var fn : justCopy) {
            var src = getClass().getResourceAsStream(fn);
            if (src == null) {
                throw new FileNotFoundException("unable to find resource file " + fn);
            }
            Files.copy(src, outDir.resolve(fn), REPLACE_EXISTING);
        }
        out = Files.newBufferedWriter(outDir.resolve("parser.hpp"));
    }

    private void includeHeaders() throws IOException {
        out.write(
                """
                // Automatically generated by github.com:belous-dp/mt-lab4-parsers-generator.git
                
                #pragma once
                
                #include "tree.hpp"
                #include "ctre.hpp"
                
                #include <cctype>
                #include <istream>
                #include <stdexcept>
                #include <string>
                #include <string_view>
                #include <vector>
                
                using namespace std::string_literals;
                
                """);
    }

    private void createTokensEnum(List<Terminal> terminals) throws IOException {
        out.write("enum class token { ");
        out.write(terminals.stream().map(Terminal::name).collect(Collectors.joining(", ")));
        out.write(", _END };\n\n");
    }

    private void createLexer(List<Terminal> terminals) throws IOException {
        out.write("""
                struct lexer_exception : std::runtime_error {
                  using std::runtime_error::runtime_error;
                };
                
                struct lexer {
                
                  lexer(std::istream& is) {
                    if (!is) {
                      throw lexer_exception{"stream is not opened"};
                    }
                    buf_ = gulp(is);
                    input = buf_;
                  }
                
                  token cur_token() const noexcept {
                    return t;
                  }
                
                  std::string cur_token_val() const noexcept {
                    return std::string{lexeme};
                  }
                
                  std::string info() const noexcept {
                    return "'"s + input.front() + "' at pos " + std::to_string(pos);
                  }
                
                  token next_token() {
                    while (!is_eof() && is_space()) {
                      input.remove_prefix(1);
                      pos++;
                    }
                    if (is_eof()) {
                      t = token::_END;
                      return t;
                    }
                """);
        var first = true;
        for (var tok : terminals) {
            out.write(first ? "    " : " else ");
            first = false;
            out.write("if (");
            String take;
            if (tok.isRegex()) {
                out.write("auto m = ctre::starts_with<\"" + tok.value() + "\">(input)");
                take = "m.size()";
            } else {
                out.write("input.starts_with(\"" + tok.value() + "\")");
                take = String.valueOf(tok.value().length());
            }
            out.write(") {\n        t = token::" + tok.name() + ";\n        take(" + take + ");\n    }");
        }
        out.write("""
                
                    return t;
                  }
                
                private:
                  std::string gulp(std::istream &in) {
                    std::string ret;
                    char buffer[4096];
                    while (in.read(buffer, sizeof(buffer)))
                      ret.append(buffer, sizeof(buffer));
                    ret.append(buffer, in.gcount());
                    return ret;
                  }
                
                  bool is_eof() const noexcept {
                    return input.empty();
                  }
                
                  bool is_space() const noexcept {
                    return std::isspace(static_cast<unsigned char>(input.front()));
                  }
                
                  void take(size_t n) {
                    lexeme = input.substr(0, n);
                    input.remove_prefix(n);
                    pos += n;
                  }
                
                  std::string buf_;
                  std::string_view input;
                  std::string_view lexeme;
                  size_t pos{0};
                  token t;
                  char ch;
                };
                
                """);
    }

    private void createParser(List<NonTerminal> nonterminals, String includes) throws IOException {
        if (!includes.isEmpty()) {
            out.write(includes);
            out.write("\n");
        }
        out.write("""
                struct parser_exception : std::runtime_error {
                  using std::runtime_error::runtime_error;
                };
                
                class parser {
                  struct lexer lexer;
                
                """);
        new RecursiveDescentGenerator(nonterminals, out, this::first1).generate();
        out.write("""
                  parser_exception invalid_token(std::string&& n) {
                    auto reason = lexer.cur_token() == token::_END
                                      ? "expected a token, but got EOF"
                                      : ("unexpected token " + lexer.info());
                    return parser_exception{n + ": " + reason};
                  }
                
                public:
                  parser(std::istream& is) : lexer(is) {}
                
                """);
        var s = nonterminals.getFirst().name;
        out.write(String.format("  struct %s parse() {\n    lexer.next_token();\n    return %s();\n  }\n};\n", s, s));
    }

    private boolean checkLL1(List<NonTerminal> nonterminalRules) {
        buildFirstFollow(nonterminalRules);
        for (var nt : nonterminalRules) {
            var A = nt.name;
            for (int i = 0; i < nt.branches.size(); i++) {
                var a = nt.branches.get(i);
                for (int j = 0; j < nt.branches.size(); j++) {
                    if (i == j) {
                        continue;
                    }
                    var b = nt.branches.get(j);
                    var first1a = first1(a, A);
                    var firstb = first(b);
                    if (first1a.stream().anyMatch(firstb::contains)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }


    private void buildFirstFollow(List<NonTerminal> nonterminals) {
        nonterminals.forEach(nt -> FIRST.put(nt.name, new HashSet<>()));

        var changed = true;
        while (changed) {
            changed = false;
            for (var nt : nonterminals) {
                var set = FIRST.get(nt.name);
                for (var br : nt.branches) {
                    changed |= set.addAll(first(br));
                }
            }
        }

        nonterminals.forEach(nt -> FOLLOW.put(nt.name, new HashSet<>()));
        FOLLOW.get(nonterminals.getFirst().name).add("_END"); // '$'/EOF
        changed = true;
        while (changed) {
            changed = false;
            for (var nt : nonterminals) {
                var A = nt.name;
                for (var br : nt.branches) {
                    var brs = br.symbs;
                    for (int i = 0; i < brs.size(); i++) {
                        var B = brs.get(i);
                        if (!isTerminal(B)) {
                            changed |= FOLLOW.get(B.name).addAll(first1(brs.subList(i + 1, brs.size()), A));
                        }
                    }
                }
            }
        }
    }

    private boolean isTerminal(NonTerminal.Branch.Symb symb) {
        return 'A' <= symb.name.charAt(0) && symb.name.charAt(0) <= 'Z';
    }

    private Set<String> first(NonTerminal.Branch alpha) {
        return first(alpha.symbs);
    }

    private Set<String> first(List<NonTerminal.Branch.Symb> alpha) {
        var res = new HashSet<String>();
        if (alpha.isEmpty()) {
            res.add(null);
        } else {
            var e = alpha.getFirst();
            if (isTerminal(e)) {
                res.add(e.name);
            } else {
                var eps = false;
                for (var a : FIRST.get(e.name)) {
                    if (a == null) {
                        eps = true;
                    } else {
                        res.add(a);
                    }
                }
                if (eps) {
                    res.addAll(first(alpha.subList(1, alpha.size())));
                }
            }
        }
        return res;
    }

    private Set<String> first1(NonTerminal.Branch alpha, String A) {
        return first1(alpha.symbs, A);
    }

    private Set<String> first1(List<NonTerminal.Branch.Symb> alpha, String A) {
        var res = first(alpha);
        if (res.contains(null)) {
            res.remove(null);
            res.addAll(FOLLOW.get(A));
        }
        return res;
    }

}
